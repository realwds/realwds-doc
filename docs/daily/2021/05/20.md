# 2021年05月20日

::: tip 天气
今日杭州晴，天气温和。
:::

## 作用域，作用域链和闭包

[[toc]]

### 作用域

指的是一个变量和函数的作用范围，`JS` 中函数内声明的所有变量在函数体内始终是可见的，在 `ES6` 前有全局作用域和局部作用域，但是没有块级作用域（ `catch` 只在其内部生效），局部变量的优先级高于全局变量。

### 作用域链

每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。

作用域链的开始是当前代码执行环境的变量对象，常被称之为“活跃对象”（ `AO` ），变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中。

### 闭包

红宝书( `p178` )上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。

`MDN` 对闭包的定义为：闭包是指那些能够访问自由变量的函数。

其中**自由变量**，指在函数中使用的，但既不是函数参数 `arguments` 也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。

``` js
function getOuter(){
  var date = '1127';
  function getDate(str){
    console.log(str + date);  //访问外部的date
  }
  return getDate('今天是：'); //"今天是：1127"
}
getOuter();
```

其中 `date` 既不是参数 `arguments`，也不是局部变量，所以 `date` 是自由变量。

总结起来就是下面两点：

- 是一个函数（比如，内部函数从父函数中返回）
- 能访问上级函数作用域中的变量（哪怕上级函数上下文已经销毁）

### 经典闭包题解

由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();	// 3
data[1]();	// 3
data[2]();	// 3
```
如果要强制返回预期的结果1，2，3怎么办？

#### 方法1：立即执行函数

``` js
for (var i = 0; i < 3; i++) {
    (function(num) {
        setTimeout(function() {
            console.log(num);
        }, 1000);
    })(i);
}
// 0
// 1
// 2
```

#### 方法2：返回一个匿名函数赋值

``` js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (num) {
      return function(){
          console.log(num);
      }
  })(i);
}

data[0]();	// 0
data[1]();	// 1
data[2]();	// 2
```

无论是立即执行函数还是返回一个匿名函数赋值，原理上都是因为变量的按值传递，所以会将变量i的值复制给实参 `num`，在匿名函数的内部又创建了一个用于访问 `num` 的匿名函数，这样每个函数都有了一个 `num` 的副本，互不影响了。

#### 方法3：使用ES6中的let

``` js
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

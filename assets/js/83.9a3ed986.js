(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{467:function(_,t,o){"use strict";o.r(t);var v=o(28),e=Object(v.a)({},(function(){var _=this,t=_.$createElement,o=_._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[o("h1",{attrs:{id:"_2021年05月22日"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2021年05月22日"}},[_._v("#")]),_._v(" 2021年05月22日")]),_._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[_._v("天气")]),_._v(" "),o("p",[_._v("今日杭州晴，天气温和。")])]),_._v(" "),o("h2",{attrs:{id:"原型和原型链"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[_._v("#")]),_._v(" 原型和原型链")]),_._v(" "),o("h3",{attrs:{id:"原型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[_._v("#")]),_._v(" 原型")]),_._v(" "),o("p",[_._v("每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的 "),o("code",[_._v("prototype")]),_._v(" 属性上，而非对象实例本身。")]),_._v(" "),o("p",[o("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/realwds/cdn@master/blog/prototype.13cf6ccb.336ksqx3fz20.jpg",alt:""}})]),_._v(" "),o("h3",{attrs:{id:"原型链"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[_._v("#")]),_._v(" 原型链")]),_._v(" "),o("p",[_._v("每个对象拥有一个原型对象，通过 "),o("code",[_._v("__proto__")]),_._v(" 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 "),o("code",[_._v("null")]),_._v("。")]),_._v(" "),o("p",[_._v("这种关系被称为原型链 ("),o("code",[_._v("prototype chain")]),_._v(")，通过原型链一个对象会拥有定义在其他对象中的属性和方法。")]),_._v(" "),o("h3",{attrs:{id:"总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),o("ul",[o("li",[o("p",[o("code",[_._v("Symbol")]),_._v(" 作为构造函数来说并不完整，因为不支持语法 "),o("code",[_._v("new Symbol()")]),_._v("，但其原型上拥有 "),o("code",[_._v("constructor")]),_._v(" 属性，即 "),o("code",[_._v("Symbol.prototype.constructor")]),_._v("。")])]),_._v(" "),o("li",[o("p",[_._v("引用类型 "),o("code",[_._v("constructor")]),_._v(" 属性值是可以修改的，但是对于基本类型来说是只读的，当然 "),o("code",[_._v("null")]),_._v(" 和 "),o("code",[_._v("undefined")]),_._v("， 没有 "),o("code",[_._v("constructor")]),_._v(" 属性。")])]),_._v(" "),o("li",[o("p",[o("code",[_._v("__proto__")]),_._v(" 是每个实例上都有的属性，"),o("code",[_._v("prototype")]),_._v(" 是构造函数的属性，在实例上并不存在，所以这两个并不一样，但 "),o("code",[_._v("p.__proto__")]),_._v(" 和 "),o("code",[_._v("Parent.prototype")]),_._v(" 指向同一个对象。")])]),_._v(" "),o("li",[o("p",[o("code",[_._v("__proto__")]),_._v(" 属性在 "),o("code",[_._v("ES6")]),_._v(" 时被标准化，但因为性能问题并不推荐使用，推荐使用 "),o("code",[_._v("Object.getPrototypeOf()")]),_._v("。")])]),_._v(" "),o("li",[o("p",[_._v("每个对象拥有一个原型对象，通过 "),o("code",[_._v("__proto__")]),_._v(" 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 "),o("code",[_._v("null")]),_._v("，这就是原型链。")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);
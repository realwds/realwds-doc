(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{454:function(t,e,v){"use strict";v.r(e);var _=v(28),c=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"_2021年05月09日"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2021年05月09日"}},[t._v("#")]),t._v(" 2021年05月09日")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("天气")]),t._v(" "),v("p",[t._v("今日杭州晴，天气温和。")])]),t._v(" "),v("h2",{attrs:{id:"vue-中的-computed-是如何实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-computed-是如何实现的"}},[t._v("#")]),t._v(" Vue 中的 computed 是如何实现的")]),t._v(" "),v("p",[v("code",[t._v("computed")]),t._v(" 本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的 "),v("code",[t._v("getter")]),t._v("，而不是用户定义的方法。")]),t._v(" "),v("p",[v("code",[t._v("computed")]),t._v(" 内部实现了一个惰性的 "),v("code",[t._v("watcher")]),t._v("，在实例化的时候不会去求值，其内部通过 "),v("code",[t._v("dirty")]),t._v(" 属性标记计算属性是否需要重新求值。")]),t._v(" "),v("p",[t._v("当 "),v("code",[t._v("computed")]),t._v(" 依赖的任一状态（不一定是 "),v("code",[t._v("return")]),t._v(" 中的）发生变化，都会通知这个惰性 "),v("code",[t._v("watcher")]),t._v("，让它把 "),v("code",[t._v("dirty")]),t._v(" 属性设置为 "),v("code",[t._v("true")]),t._v("。")]),t._v(" "),v("p",[t._v("所以，当再次读取这个计算属性的时候，就会重新去求值。")])])}),[],!1,null,null,null);e.default=c.exports}}]);